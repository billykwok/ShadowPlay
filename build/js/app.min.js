var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var collections;
(function (collections) {
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var has = function (obj, prop) {
        return _hasOwnProperty.call(obj, prop);
    };
    function defaultCompare(a, b) {
        if (a < b) {
            return -1;
        }
        else if (a === b) {
            return 0;
        }
        else {
            return 1;
        }
    }
    collections.defaultCompare = defaultCompare;
    function defaultEquals(a, b) {
        return a === b;
    }
    collections.defaultEquals = defaultEquals;
    function defaultToString(item) {
        if (item === null) {
            return 'COLLECTION_NULL';
        }
        else if (collections.isUndefined(item)) {
            return 'COLLECTION_UNDEFINED';
        }
        else if (collections.isString(item)) {
            return '$s' + item;
        }
        else {
            return '$o' + item.toString();
        }
    }
    collections.defaultToString = defaultToString;
    function makeString(item, join) {
        if (join === void 0) { join = ","; }
        if (item === null) {
            return 'COLLECTION_NULL';
        }
        else if (collections.isUndefined(item)) {
            return 'COLLECTION_UNDEFINED';
        }
        else if (collections.isString(item)) {
            return item.toString();
        }
        else {
            var toret = "{";
            var first = true;
            for (var prop in item) {
                if (has(item, prop)) {
                    if (first)
                        first = false;
                    else
                        toret = toret + join;
                    toret = toret + prop + ":" + item[prop];
                }
            }
            return toret + "}";
        }
    }
    collections.makeString = makeString;
    function isFunction(func) {
        return (typeof func) === 'function';
    }
    collections.isFunction = isFunction;
    function isUndefined(obj) {
        return (typeof obj) === 'undefined';
    }
    collections.isUndefined = isUndefined;
    function isString(obj) {
        return Object.prototype.toString.call(obj) === '[object String]';
    }
    collections.isString = isString;
    function reverseCompareFunction(compareFunction) {
        if (!collections.isFunction(compareFunction)) {
            return function (a, b) {
                if (a < b) {
                    return 1;
                }
                else if (a === b) {
                    return 0;
                }
                else {
                    return -1;
                }
            };
        }
        else {
            return function (d, v) {
                return compareFunction(d, v) * -1;
            };
        }
    }
    collections.reverseCompareFunction = reverseCompareFunction;
    function compareToEquals(compareFunction) {
        return function (a, b) {
            return compareFunction(a, b) === 0;
        };
    }
    collections.compareToEquals = compareToEquals;
    var arrays;
    (function (arrays) {
        function indexOf(array, item, equalsFunction) {
            var equals = equalsFunction || collections.defaultEquals;
            var length = array.length;
            for (var i = 0; i < length; i++) {
                if (equals(array[i], item)) {
                    return i;
                }
            }
            return -1;
        }
        arrays.indexOf = indexOf;
        function lastIndexOf(array, item, equalsFunction) {
            var equals = equalsFunction || collections.defaultEquals;
            var length = array.length;
            for (var i = length - 1; i >= 0; i--) {
                if (equals(array[i], item)) {
                    return i;
                }
            }
            return -1;
        }
        arrays.lastIndexOf = lastIndexOf;
        function contains(array, item, equalsFunction) {
            return arrays.indexOf(array, item, equalsFunction) >= 0;
        }
        arrays.contains = contains;
        function remove(array, item, equalsFunction) {
            var index = arrays.indexOf(array, item, equalsFunction);
            if (index < 0) {
                return false;
            }
            array.splice(index, 1);
            return true;
        }
        arrays.remove = remove;
        function frequency(array, item, equalsFunction) {
            var equals = equalsFunction || collections.defaultEquals;
            var length = array.length;
            var freq = 0;
            for (var i = 0; i < length; i++) {
                if (equals(array[i], item)) {
                    freq++;
                }
            }
            return freq;
        }
        arrays.frequency = frequency;
        function equals(array1, array2, equalsFunction) {
            var equals = equalsFunction || collections.defaultEquals;
            if (array1.length !== array2.length) {
                return false;
            }
            var length = array1.length;
            for (var i = 0; i < length; i++) {
                if (!equals(array1[i], array2[i])) {
                    return false;
                }
            }
            return true;
        }
        arrays.equals = equals;
        function copy(array) {
            return array.concat();
        }
        arrays.copy = copy;
        function swap(array, i, j) {
            if (i < 0 || i >= array.length || j < 0 || j >= array.length) {
                return false;
            }
            var temp = array[i];
            array[i] = array[j];
            array[j] = temp;
            return true;
        }
        arrays.swap = swap;
        function toString(array) {
            return '[' + array.toString() + ']';
        }
        arrays.toString = toString;
        function forEach(array, callback) {
            var lenght = array.length;
            for (var i = 0; i < lenght; i++) {
                if (callback(array[i]) === false) {
                    return;
                }
            }
        }
        arrays.forEach = forEach;
    })(arrays = collections.arrays || (collections.arrays = {}));
    var LinkedList = (function () {
        function LinkedList() {
            this.firstNode = null;
            this.lastNode = null;
            this.nElements = 0;
        }
        LinkedList.prototype.add = function (item, index) {
            if (collections.isUndefined(index)) {
                index = this.nElements;
            }
            if (index < 0 || index > this.nElements || collections.isUndefined(item)) {
                return false;
            }
            var newNode = this.createNode(item);
            if (this.nElements === 0) {
                this.firstNode = newNode;
                this.lastNode = newNode;
            }
            else if (index === this.nElements) {
                this.lastNode.next = newNode;
                this.lastNode = newNode;
            }
            else if (index === 0) {
                newNode.next = this.firstNode;
                this.firstNode = newNode;
            }
            else {
                var prev = this.nodeAtIndex(index - 1);
                newNode.next = prev.next;
                prev.next = newNode;
            }
            this.nElements++;
            return true;
        };
        LinkedList.prototype.first = function () {
            if (this.firstNode !== null) {
                return this.firstNode.element;
            }
            return undefined;
        };
        LinkedList.prototype.last = function () {
            if (this.lastNode !== null) {
                return this.lastNode.element;
            }
            return undefined;
        };
        LinkedList.prototype.elementAtIndex = function (index) {
            var node = this.nodeAtIndex(index);
            if (node === null) {
                return undefined;
            }
            return node.element;
        };
        LinkedList.prototype.indexOf = function (item, equalsFunction) {
            var equalsF = equalsFunction || collections.defaultEquals;
            if (collections.isUndefined(item)) {
                return -1;
            }
            var currentNode = this.firstNode;
            var index = 0;
            while (currentNode !== null) {
                if (equalsF(currentNode.element, item)) {
                    return index;
                }
                index++;
                currentNode = currentNode.next;
            }
            return -1;
        };
        LinkedList.prototype.contains = function (item, equalsFunction) {
            return (this.indexOf(item, equalsFunction) >= 0);
        };
        LinkedList.prototype.remove = function (item, equalsFunction) {
            var equalsF = equalsFunction || collections.defaultEquals;
            if (this.nElements < 1 || collections.isUndefined(item)) {
                return false;
            }
            var previous = null;
            var currentNode = this.firstNode;
            while (currentNode !== null) {
                if (equalsF(currentNode.element, item)) {
                    if (currentNode === this.firstNode) {
                        this.firstNode = this.firstNode.next;
                        if (currentNode === this.lastNode) {
                            this.lastNode = null;
                        }
                    }
                    else if (currentNode === this.lastNode) {
                        this.lastNode = previous;
                        previous.next = currentNode.next;
                        currentNode.next = null;
                    }
                    else {
                        previous.next = currentNode.next;
                        currentNode.next = null;
                    }
                    this.nElements--;
                    return true;
                }
                previous = currentNode;
                currentNode = currentNode.next;
            }
            return false;
        };
        LinkedList.prototype.clear = function () {
            this.firstNode = null;
            this.lastNode = null;
            this.nElements = 0;
        };
        LinkedList.prototype.equals = function (other, equalsFunction) {
            var eqF = equalsFunction || collections.defaultEquals;
            if (!(other instanceof collections.LinkedList)) {
                return false;
            }
            if (this.size() !== other.size()) {
                return false;
            }
            return this.equalsAux(this.firstNode, other.firstNode, eqF);
        };
        LinkedList.prototype.equalsAux = function (n1, n2, eqF) {
            while (n1 !== null) {
                if (!eqF(n1.element, n2.element)) {
                    return false;
                }
                n1 = n1.next;
                n2 = n2.next;
            }
            return true;
        };
        LinkedList.prototype.removeElementAtIndex = function (index) {
            if (index < 0 || index >= this.nElements) {
                return undefined;
            }
            var element;
            if (this.nElements === 1) {
                element = this.firstNode.element;
                this.firstNode = null;
                this.lastNode = null;
            }
            else {
                var previous = this.nodeAtIndex(index - 1);
                if (previous === null) {
                    element = this.firstNode.element;
                    this.firstNode = this.firstNode.next;
                }
                else if (previous.next === this.lastNode) {
                    element = this.lastNode.element;
                    this.lastNode = previous;
                }
                if (previous !== null) {
                    element = previous.next.element;
                    previous.next = previous.next.next;
                }
            }
            this.nElements--;
            return element;
        };
        LinkedList.prototype.forEach = function (callback) {
            var currentNode = this.firstNode;
            while (currentNode !== null) {
                if (callback(currentNode.element) === false) {
                    break;
                }
                currentNode = currentNode.next;
            }
        };
        LinkedList.prototype.reverse = function () {
            var previous = null;
            var current = this.firstNode;
            var temp = null;
            while (current !== null) {
                temp = current.next;
                current.next = previous;
                previous = current;
                current = temp;
            }
            temp = this.firstNode;
            this.firstNode = this.lastNode;
            this.lastNode = temp;
        };
        LinkedList.prototype.toArray = function () {
            var array = [];
            var currentNode = this.firstNode;
            while (currentNode !== null) {
                array.push(currentNode.element);
                currentNode = currentNode.next;
            }
            return array;
        };
        LinkedList.prototype.size = function () {
            return this.nElements;
        };
        LinkedList.prototype.isEmpty = function () {
            return this.nElements <= 0;
        };
        LinkedList.prototype.toString = function () {
            return collections.arrays.toString(this.toArray());
        };
        LinkedList.prototype.nodeAtIndex = function (index) {
            if (index < 0 || index >= this.nElements) {
                return null;
            }
            if (index === (this.nElements - 1)) {
                return this.lastNode;
            }
            var node = this.firstNode;
            for (var i = 0; i < index; i++) {
                node = node.next;
            }
            return node;
        };
        LinkedList.prototype.createNode = function (item) {
            return {
                element: item,
                next: null
            };
        };
        return LinkedList;
    })();
    collections.LinkedList = LinkedList;
    var Dictionary = (function () {
        function Dictionary(toStrFunction) {
            this.table = {};
            this.nElements = 0;
            this.toStr = toStrFunction || collections.defaultToString;
        }
        Dictionary.prototype.getValue = function (key) {
            var pair = this.table['$' + this.toStr(key)];
            if (collections.isUndefined(pair)) {
                return undefined;
            }
            return pair.value;
        };
        Dictionary.prototype.setValue = function (key, value) {
            if (collections.isUndefined(key) || collections.isUndefined(value)) {
                return undefined;
            }
            var ret;
            var k = '$' + this.toStr(key);
            var previousElement = this.table[k];
            if (collections.isUndefined(previousElement)) {
                this.nElements++;
                ret = undefined;
            }
            else {
                ret = previousElement.value;
            }
            this.table[k] = {
                key: key,
                value: value
            };
            return ret;
        };
        Dictionary.prototype.remove = function (key) {
            var k = '$' + this.toStr(key);
            var previousElement = this.table[k];
            if (!collections.isUndefined(previousElement)) {
                delete this.table[k];
                this.nElements--;
                return previousElement.value;
            }
            return undefined;
        };
        Dictionary.prototype.keys = function () {
            var array = [];
            for (var name in this.table) {
                if (has(this.table, name)) {
                    var pair = this.table[name];
                    array.push(pair.key);
                }
            }
            return array;
        };
        Dictionary.prototype.values = function () {
            var array = [];
            for (var name in this.table) {
                if (has(this.table, name)) {
                    var pair = this.table[name];
                    array.push(pair.value);
                }
            }
            return array;
        };
        Dictionary.prototype.forEach = function (callback) {
            for (var name in this.table) {
                if (has(this.table, name)) {
                    var pair = this.table[name];
                    var ret = callback(pair.key, pair.value);
                    if (ret === false) {
                        return;
                    }
                }
            }
        };
        Dictionary.prototype.containsKey = function (key) {
            return !collections.isUndefined(this.getValue(key));
        };
        Dictionary.prototype.clear = function () {
            this.table = {};
            this.nElements = 0;
        };
        Dictionary.prototype.size = function () {
            return this.nElements;
        };
        Dictionary.prototype.isEmpty = function () {
            return this.nElements <= 0;
        };
        Dictionary.prototype.toString = function () {
            var toret = "{";
            this.forEach(function (k, v) {
                toret = toret + "\n\t" + k.toString() + " : " + v.toString();
            });
            return toret + "\n}";
        };
        return Dictionary;
    })();
    collections.Dictionary = Dictionary;
    var LinkedDictionaryPair = (function () {
        function LinkedDictionaryPair(key, value) {
            this.key = key;
            this.value = value;
        }
        LinkedDictionaryPair.prototype.unlink = function () {
            this.prev.next = this.next;
            this.next.prev = this.prev;
        };
        return LinkedDictionaryPair;
    })();
    var LinkedDictionary = (function (_super) {
        __extends(LinkedDictionary, _super);
        function LinkedDictionary(toStrFunction) {
            _super.call(this, toStrFunction);
            this.head = new LinkedDictionaryPair(null, null);
            this.tail = new LinkedDictionaryPair(null, null);
            this.head.next = this.tail;
            this.tail.prev = this.head;
        }
        LinkedDictionary.prototype.appendToTail = function (entry) {
            var lastNode = this.tail.prev;
            lastNode.next = entry;
            entry.prev = lastNode;
            entry.next = this.tail;
            this.tail.prev = entry;
        };
        LinkedDictionary.prototype.getLinkedDictionaryPair = function (key) {
            if (collections.isUndefined(key)) {
                return undefined;
            }
            var k = '$' + this.toStr(key);
            var pair = (this.table[k]);
            return pair;
        };
        LinkedDictionary.prototype.getValue = function (key) {
            var pair = this.getLinkedDictionaryPair(key);
            if (!collections.isUndefined(pair)) {
                return pair.value;
            }
            return undefined;
        };
        LinkedDictionary.prototype.remove = function (key) {
            var pair = this.getLinkedDictionaryPair(key);
            if (!collections.isUndefined(pair)) {
                _super.prototype.remove.call(this, key);
                pair.unlink();
                return pair.value;
            }
            return undefined;
        };
        LinkedDictionary.prototype.clear = function () {
            _super.prototype.clear.call(this);
            this.head.next = this.tail;
            this.tail.prev = this.head;
        };
        LinkedDictionary.prototype.replace = function (oldPair, newPair) {
            var k = '$' + this.toStr(newPair.key);
            newPair.next = oldPair.next;
            newPair.prev = oldPair.prev;
            this.remove(oldPair.key);
            newPair.prev.next = newPair;
            newPair.next.prev = newPair;
            this.table[k] = newPair;
            ++this.nElements;
        };
        LinkedDictionary.prototype.setValue = function (key, value) {
            if (collections.isUndefined(key) || collections.isUndefined(value)) {
                return undefined;
            }
            var existingPair = this.getLinkedDictionaryPair(key);
            var newPair = new LinkedDictionaryPair(key, value);
            var k = '$' + this.toStr(key);
            if (!collections.isUndefined(existingPair)) {
                this.replace(existingPair, newPair);
                return existingPair.value;
            }
            else {
                this.appendToTail(newPair);
                this.table[k] = newPair;
                ++this.nElements;
                return undefined;
            }
        };
        LinkedDictionary.prototype.keys = function () {
            var array = [];
            this.forEach(function (key, value) {
                array.push(key);
            });
            return array;
        };
        LinkedDictionary.prototype.values = function () {
            var array = [];
            this.forEach(function (key, value) {
                array.push(value);
            });
            return array;
        };
        LinkedDictionary.prototype.forEach = function (callback) {
            var crawlNode = this.head.next;
            while (crawlNode.next != null) {
                var ret = callback(crawlNode.key, crawlNode.value);
                if (ret === false) {
                    return;
                }
                crawlNode = crawlNode.next;
            }
        };
        return LinkedDictionary;
    })(Dictionary);
    collections.LinkedDictionary = LinkedDictionary;
    var MultiDictionary = (function () {
        function MultiDictionary(toStrFunction, valuesEqualsFunction, allowDuplicateValues) {
            if (allowDuplicateValues === void 0) { allowDuplicateValues = false; }
            this.dict = new Dictionary(toStrFunction);
            this.equalsF = valuesEqualsFunction || collections.defaultEquals;
            this.allowDuplicate = allowDuplicateValues;
        }
        MultiDictionary.prototype.getValue = function (key) {
            var values = this.dict.getValue(key);
            if (collections.isUndefined(values)) {
                return [];
            }
            return collections.arrays.copy(values);
        };
        MultiDictionary.prototype.setValue = function (key, value) {
            if (collections.isUndefined(key) || collections.isUndefined(value)) {
                return false;
            }
            if (!this.containsKey(key)) {
                this.dict.setValue(key, [value]);
                return true;
            }
            var array = this.dict.getValue(key);
            if (!this.allowDuplicate) {
                if (collections.arrays.contains(array, value, this.equalsF)) {
                    return false;
                }
            }
            array.push(value);
            return true;
        };
        MultiDictionary.prototype.remove = function (key, value) {
            if (collections.isUndefined(value)) {
                var v = this.dict.remove(key);
                return !collections.isUndefined(v);
            }
            var array = this.dict.getValue(key);
            if (collections.arrays.remove(array, value, this.equalsF)) {
                if (array.length === 0) {
                    this.dict.remove(key);
                }
                return true;
            }
            return false;
        };
        MultiDictionary.prototype.keys = function () {
            return this.dict.keys();
        };
        MultiDictionary.prototype.values = function () {
            var values = this.dict.values();
            var array = [];
            for (var i = 0; i < values.length; i++) {
                var v = values[i];
                for (var j = 0; j < v.length; j++) {
                    array.push(v[j]);
                }
            }
            return array;
        };
        MultiDictionary.prototype.containsKey = function (key) {
            return this.dict.containsKey(key);
        };
        MultiDictionary.prototype.clear = function () {
            this.dict.clear();
        };
        MultiDictionary.prototype.size = function () {
            return this.dict.size();
        };
        MultiDictionary.prototype.isEmpty = function () {
            return this.dict.isEmpty();
        };
        return MultiDictionary;
    })();
    collections.MultiDictionary = MultiDictionary;
    var Heap = (function () {
        function Heap(compareFunction) {
            this.data = [];
            this.compare = compareFunction || collections.defaultCompare;
        }
        Heap.prototype.leftChildIndex = function (nodeIndex) {
            return (2 * nodeIndex) + 1;
        };
        Heap.prototype.rightChildIndex = function (nodeIndex) {
            return (2 * nodeIndex) + 2;
        };
        Heap.prototype.parentIndex = function (nodeIndex) {
            return Math.floor((nodeIndex - 1) / 2);
        };
        Heap.prototype.minIndex = function (leftChild, rightChild) {
            if (rightChild >= this.data.length) {
                if (leftChild >= this.data.length) {
                    return -1;
                }
                else {
                    return leftChild;
                }
            }
            else {
                if (this.compare(this.data[leftChild], this.data[rightChild]) <= 0) {
                    return leftChild;
                }
                else {
                    return rightChild;
                }
            }
        };
        Heap.prototype.siftUp = function (index) {
            var parent = this.parentIndex(index);
            while (index > 0 && this.compare(this.data[parent], this.data[index]) > 0) {
                collections.arrays.swap(this.data, parent, index);
                index = parent;
                parent = this.parentIndex(index);
            }
        };
        Heap.prototype.siftDown = function (nodeIndex) {
            var min = this.minIndex(this.leftChildIndex(nodeIndex), this.rightChildIndex(nodeIndex));
            while (min >= 0 && this.compare(this.data[nodeIndex], this.data[min]) > 0) {
                collections.arrays.swap(this.data, min, nodeIndex);
                nodeIndex = min;
                min = this.minIndex(this.leftChildIndex(nodeIndex), this.rightChildIndex(nodeIndex));
            }
        };
        Heap.prototype.peek = function () {
            if (this.data.length > 0) {
                return this.data[0];
            }
            else {
                return undefined;
            }
        };
        Heap.prototype.add = function (element) {
            if (collections.isUndefined(element)) {
                return undefined;
            }
            this.data.push(element);
            this.siftUp(this.data.length - 1);
            return true;
        };
        Heap.prototype.removeRoot = function () {
            if (this.data.length > 0) {
                var obj = this.data[0];
                this.data[0] = this.data[this.data.length - 1];
                this.data.splice(this.data.length - 1, 1);
                if (this.data.length > 0) {
                    this.siftDown(0);
                }
                return obj;
            }
            return undefined;
        };
        Heap.prototype.contains = function (element) {
            var equF = collections.compareToEquals(this.compare);
            return collections.arrays.contains(this.data, element, equF);
        };
        Heap.prototype.size = function () {
            return this.data.length;
        };
        Heap.prototype.isEmpty = function () {
            return this.data.length <= 0;
        };
        Heap.prototype.clear = function () {
            this.data.length = 0;
        };
        Heap.prototype.forEach = function (callback) {
            collections.arrays.forEach(this.data, callback);
        };
        return Heap;
    })();
    collections.Heap = Heap;
    var Stack = (function () {
        function Stack() {
            this.list = new LinkedList();
        }
        Stack.prototype.push = function (elem) {
            return this.list.add(elem, 0);
        };
        Stack.prototype.add = function (elem) {
            return this.list.add(elem, 0);
        };
        Stack.prototype.pop = function () {
            return this.list.removeElementAtIndex(0);
        };
        Stack.prototype.peek = function () {
            return this.list.first();
        };
        Stack.prototype.size = function () {
            return this.list.size();
        };
        Stack.prototype.contains = function (elem, equalsFunction) {
            return this.list.contains(elem, equalsFunction);
        };
        Stack.prototype.isEmpty = function () {
            return this.list.isEmpty();
        };
        Stack.prototype.clear = function () {
            this.list.clear();
        };
        Stack.prototype.forEach = function (callback) {
            this.list.forEach(callback);
        };
        return Stack;
    })();
    collections.Stack = Stack;
    var Queue = (function () {
        function Queue() {
            this.list = new LinkedList();
        }
        Queue.prototype.enqueue = function (elem) {
            return this.list.add(elem);
        };
        Queue.prototype.add = function (elem) {
            return this.list.add(elem);
        };
        Queue.prototype.dequeue = function () {
            if (this.list.size() !== 0) {
                var el = this.list.first();
                this.list.removeElementAtIndex(0);
                return el;
            }
            return undefined;
        };
        Queue.prototype.peek = function () {
            if (this.list.size() !== 0) {
                return this.list.first();
            }
            return undefined;
        };
        Queue.prototype.size = function () {
            return this.list.size();
        };
        Queue.prototype.contains = function (elem, equalsFunction) {
            return this.list.contains(elem, equalsFunction);
        };
        Queue.prototype.isEmpty = function () {
            return this.list.size() <= 0;
        };
        Queue.prototype.clear = function () {
            this.list.clear();
        };
        Queue.prototype.forEach = function (callback) {
            this.list.forEach(callback);
        };
        return Queue;
    })();
    collections.Queue = Queue;
    var PriorityQueue = (function () {
        function PriorityQueue(compareFunction) {
            this.heap = new Heap(collections.reverseCompareFunction(compareFunction));
        }
        PriorityQueue.prototype.enqueue = function (element) {
            return this.heap.add(element);
        };
        PriorityQueue.prototype.add = function (element) {
            return this.heap.add(element);
        };
        PriorityQueue.prototype.dequeue = function () {
            if (this.heap.size() !== 0) {
                var el = this.heap.peek();
                this.heap.removeRoot();
                return el;
            }
            return undefined;
        };
        PriorityQueue.prototype.peek = function () {
            return this.heap.peek();
        };
        PriorityQueue.prototype.contains = function (element) {
            return this.heap.contains(element);
        };
        PriorityQueue.prototype.isEmpty = function () {
            return this.heap.isEmpty();
        };
        PriorityQueue.prototype.size = function () {
            return this.heap.size();
        };
        PriorityQueue.prototype.clear = function () {
            this.heap.clear();
        };
        PriorityQueue.prototype.forEach = function (callback) {
            this.heap.forEach(callback);
        };
        return PriorityQueue;
    })();
    collections.PriorityQueue = PriorityQueue;
    var Set = (function () {
        function Set(toStringFunction) {
            this.dictionary = new Dictionary(toStringFunction);
        }
        Set.prototype.contains = function (element) {
            return this.dictionary.containsKey(element);
        };
        Set.prototype.add = function (element) {
            if (this.contains(element) || collections.isUndefined(element)) {
                return false;
            }
            else {
                this.dictionary.setValue(element, element);
                return true;
            }
        };
        Set.prototype.intersection = function (otherSet) {
            var set = this;
            this.forEach(function (element) {
                if (!otherSet.contains(element)) {
                    set.remove(element);
                }
                return true;
            });
        };
        Set.prototype.union = function (otherSet) {
            var set = this;
            otherSet.forEach(function (element) {
                set.add(element);
                return true;
            });
        };
        Set.prototype.difference = function (otherSet) {
            var set = this;
            otherSet.forEach(function (element) {
                set.remove(element);
                return true;
            });
        };
        Set.prototype.isSubsetOf = function (otherSet) {
            if (this.size() > otherSet.size()) {
                return false;
            }
            var isSub = true;
            this.forEach(function (element) {
                if (!otherSet.contains(element)) {
                    isSub = false;
                    return false;
                }
                return true;
            });
            return isSub;
        };
        Set.prototype.remove = function (element) {
            if (!this.contains(element)) {
                return false;
            }
            else {
                this.dictionary.remove(element);
                return true;
            }
        };
        Set.prototype.forEach = function (callback) {
            this.dictionary.forEach(function (k, v) {
                return callback(v);
            });
        };
        Set.prototype.toArray = function () {
            return this.dictionary.values();
        };
        Set.prototype.isEmpty = function () {
            return this.dictionary.isEmpty();
        };
        Set.prototype.size = function () {
            return this.dictionary.size();
        };
        Set.prototype.clear = function () {
            this.dictionary.clear();
        };
        Set.prototype.toString = function () {
            return collections.arrays.toString(this.toArray());
        };
        return Set;
    })();
    collections.Set = Set;
    var Bag = (function () {
        function Bag(toStrFunction) {
            this.toStrF = toStrFunction || collections.defaultToString;
            this.dictionary = new Dictionary(this.toStrF);
            this.nElements = 0;
        }
        Bag.prototype.add = function (element, nCopies) {
            if (nCopies === void 0) { nCopies = 1; }
            if (collections.isUndefined(element) || nCopies <= 0) {
                return false;
            }
            if (!this.contains(element)) {
                var node = {
                    value: element,
                    copies: nCopies
                };
                this.dictionary.setValue(element, node);
            }
            else {
                this.dictionary.getValue(element).copies += nCopies;
            }
            this.nElements += nCopies;
            return true;
        };
        Bag.prototype.count = function (element) {
            if (!this.contains(element)) {
                return 0;
            }
            else {
                return this.dictionary.getValue(element).copies;
            }
        };
        Bag.prototype.contains = function (element) {
            return this.dictionary.containsKey(element);
        };
        Bag.prototype.remove = function (element, nCopies) {
            if (nCopies === void 0) { nCopies = 1; }
            if (collections.isUndefined(element) || nCopies <= 0) {
                return false;
            }
            if (!this.contains(element)) {
                return false;
            }
            else {
                var node = this.dictionary.getValue(element);
                if (nCopies > node.copies) {
                    this.nElements -= node.copies;
                }
                else {
                    this.nElements -= nCopies;
                }
                node.copies -= nCopies;
                if (node.copies <= 0) {
                    this.dictionary.remove(element);
                }
                return true;
            }
        };
        Bag.prototype.toArray = function () {
            var a = [];
            var values = this.dictionary.values();
            var vl = values.length;
            for (var i = 0; i < vl; i++) {
                var node = values[i];
                var element = node.value;
                var copies = node.copies;
                for (var j = 0; j < copies; j++) {
                    a.push(element);
                }
            }
            return a;
        };
        Bag.prototype.toSet = function () {
            var toret = new Set(this.toStrF);
            var elements = this.dictionary.values();
            var l = elements.length;
            for (var i = 0; i < l; i++) {
                var value = elements[i].value;
                toret.add(value);
            }
            return toret;
        };
        Bag.prototype.forEach = function (callback) {
            this.dictionary.forEach(function (k, v) {
                var value = v.value;
                var copies = v.copies;
                for (var i = 0; i < copies; i++) {
                    if (callback(value) === false) {
                        return false;
                    }
                }
                return true;
            });
        };
        Bag.prototype.size = function () {
            return this.nElements;
        };
        Bag.prototype.isEmpty = function () {
            return this.nElements === 0;
        };
        Bag.prototype.clear = function () {
            this.nElements = 0;
            this.dictionary.clear();
        };
        return Bag;
    })();
    collections.Bag = Bag;
    var BSTree = (function () {
        function BSTree(compareFunction) {
            this.root = null;
            this.compare = compareFunction || collections.defaultCompare;
            this.nElements = 0;
        }
        BSTree.prototype.add = function (element) {
            if (collections.isUndefined(element)) {
                return false;
            }
            if (this.insertNode(this.createNode(element)) !== null) {
                this.nElements++;
                return true;
            }
            return false;
        };
        BSTree.prototype.clear = function () {
            this.root = null;
            this.nElements = 0;
        };
        BSTree.prototype.isEmpty = function () {
            return this.nElements === 0;
        };
        BSTree.prototype.size = function () {
            return this.nElements;
        };
        BSTree.prototype.contains = function (element) {
            if (collections.isUndefined(element)) {
                return false;
            }
            return this.searchNode(this.root, element) !== null;
        };
        BSTree.prototype.remove = function (element) {
            var node = this.searchNode(this.root, element);
            if (node === null) {
                return false;
            }
            this.removeNode(node);
            this.nElements--;
            return true;
        };
        BSTree.prototype.inorderTraversal = function (callback) {
            this.inorderTraversalAux(this.root, callback, {
                stop: false
            });
        };
        BSTree.prototype.preorderTraversal = function (callback) {
            this.preorderTraversalAux(this.root, callback, {
                stop: false
            });
        };
        BSTree.prototype.postorderTraversal = function (callback) {
            this.postorderTraversalAux(this.root, callback, {
                stop: false
            });
        };
        BSTree.prototype.levelTraversal = function (callback) {
            this.levelTraversalAux(this.root, callback);
        };
        BSTree.prototype.minimum = function () {
            if (this.isEmpty()) {
                return undefined;
            }
            return this.minimumAux(this.root).element;
        };
        BSTree.prototype.maximum = function () {
            if (this.isEmpty()) {
                return undefined;
            }
            return this.maximumAux(this.root).element;
        };
        BSTree.prototype.forEach = function (callback) {
            this.inorderTraversal(callback);
        };
        BSTree.prototype.toArray = function () {
            var array = [];
            this.inorderTraversal(function (element) {
                array.push(element);
                return true;
            });
            return array;
        };
        BSTree.prototype.height = function () {
            return this.heightAux(this.root);
        };
        BSTree.prototype.searchNode = function (node, element) {
            var cmp = null;
            while (node !== null && cmp !== 0) {
                cmp = this.compare(element, node.element);
                if (cmp < 0) {
                    node = node.leftCh;
                }
                else if (cmp > 0) {
                    node = node.rightCh;
                }
            }
            return node;
        };
        BSTree.prototype.transplant = function (n1, n2) {
            if (n1.parent === null) {
                this.root = n2;
            }
            else if (n1 === n1.parent.leftCh) {
                n1.parent.leftCh = n2;
            }
            else {
                n1.parent.rightCh = n2;
            }
            if (n2 !== null) {
                n2.parent = n1.parent;
            }
        };
        BSTree.prototype.removeNode = function (node) {
            if (node.leftCh === null) {
                this.transplant(node, node.rightCh);
            }
            else if (node.rightCh === null) {
                this.transplant(node, node.leftCh);
            }
            else {
                var y = this.minimumAux(node.rightCh);
                if (y.parent !== node) {
                    this.transplant(y, y.rightCh);
                    y.rightCh = node.rightCh;
                    y.rightCh.parent = y;
                }
                this.transplant(node, y);
                y.leftCh = node.leftCh;
                y.leftCh.parent = y;
            }
        };
        BSTree.prototype.inorderTraversalAux = function (node, callback, signal) {
            if (node === null || signal.stop) {
                return;
            }
            this.inorderTraversalAux(node.leftCh, callback, signal);
            if (signal.stop) {
                return;
            }
            signal.stop = callback(node.element) === false;
            if (signal.stop) {
                return;
            }
            this.inorderTraversalAux(node.rightCh, callback, signal);
        };
        BSTree.prototype.levelTraversalAux = function (node, callback) {
            var queue = new Queue();
            if (node !== null) {
                queue.enqueue(node);
            }
            while (!queue.isEmpty()) {
                node = queue.dequeue();
                if (callback(node.element) === false) {
                    return;
                }
                if (node.leftCh !== null) {
                    queue.enqueue(node.leftCh);
                }
                if (node.rightCh !== null) {
                    queue.enqueue(node.rightCh);
                }
            }
        };
        BSTree.prototype.preorderTraversalAux = function (node, callback, signal) {
            if (node === null || signal.stop) {
                return;
            }
            signal.stop = callback(node.element) === false;
            if (signal.stop) {
                return;
            }
            this.preorderTraversalAux(node.leftCh, callback, signal);
            if (signal.stop) {
                return;
            }
            this.preorderTraversalAux(node.rightCh, callback, signal);
        };
        BSTree.prototype.postorderTraversalAux = function (node, callback, signal) {
            if (node === null || signal.stop) {
                return;
            }
            this.postorderTraversalAux(node.leftCh, callback, signal);
            if (signal.stop) {
                return;
            }
            this.postorderTraversalAux(node.rightCh, callback, signal);
            if (signal.stop) {
                return;
            }
            signal.stop = callback(node.element) === false;
        };
        BSTree.prototype.minimumAux = function (node) {
            while (node.leftCh !== null) {
                node = node.leftCh;
            }
            return node;
        };
        BSTree.prototype.maximumAux = function (node) {
            while (node.rightCh !== null) {
                node = node.rightCh;
            }
            return node;
        };
        BSTree.prototype.heightAux = function (node) {
            if (node === null) {
                return -1;
            }
            return Math.max(this.heightAux(node.leftCh), this.heightAux(node.rightCh)) + 1;
        };
        BSTree.prototype.insertNode = function (node) {
            var parent = null;
            var position = this.root;
            var cmp = null;
            while (position !== null) {
                cmp = this.compare(node.element, position.element);
                if (cmp === 0) {
                    return null;
                }
                else if (cmp < 0) {
                    parent = position;
                    position = position.leftCh;
                }
                else {
                    parent = position;
                    position = position.rightCh;
                }
            }
            node.parent = parent;
            if (parent === null) {
                this.root = node;
            }
            else if (this.compare(node.element, parent.element) < 0) {
                parent.leftCh = node;
            }
            else {
                parent.rightCh = node;
            }
            return node;
        };
        BSTree.prototype.createNode = function (element) {
            return {
                element: element,
                leftCh: null,
                rightCh: null,
                parent: null
            };
        };
        return BSTree;
    })();
    collections.BSTree = BSTree;
})(collections || (collections = {}));
var KeyboardState = (function () {
    function KeyboardState() {
        document.addEventListener("keydown", KeyboardState.onKeyDown, false);
        document.addEventListener("keyup", KeyboardState.onKeyUp, false);
    }
    KeyboardState.keyName = function (keyCode) {
        return (KeyboardState.k[keyCode] != null) ? KeyboardState.k[keyCode] : String.fromCharCode(keyCode);
    };
    KeyboardState.onKeyUp = function (event) {
        var key = KeyboardState.keyName(event.keyCode);
        if (KeyboardState.status[key])
            KeyboardState.status[key].pressed = false;
    };
    KeyboardState.onKeyDown = function (event) {
        var key = KeyboardState.keyName(event.keyCode);
        if (!KeyboardState.status[key])
            KeyboardState.status[key] = { down: false, pressed: false, up: false, updatedPreviously: false };
    };
    KeyboardState.prototype.update = function () {
        for (var key in KeyboardState.status) {
            if (!KeyboardState.status[key].updatedPreviously) {
                KeyboardState.status[key].down = true;
                KeyboardState.status[key].pressed = true;
                KeyboardState.status[key].updatedPreviously = true;
            }
            else {
                KeyboardState.status[key].down = false;
            }
            if (KeyboardState.status[key].up) {
                delete KeyboardState.status[key];
                continue;
            }
            if (!KeyboardState.status[key].pressed)
                KeyboardState.status[key].up = true;
        }
    };
    KeyboardState.prototype.down = function (keyName) {
        return (KeyboardState.status[keyName] && KeyboardState.status[keyName].down);
    };
    KeyboardState.prototype.pressed = function (keyName) {
        return (KeyboardState.status[keyName] && KeyboardState.status[keyName].pressed);
    };
    KeyboardState.prototype.up = function (keyName) {
        return (KeyboardState.status[keyName] && KeyboardState.status[keyName].up);
    };
    KeyboardState.k = {
        8: "backspace",
        9: "tab",
        13: "enter",
        16: "shift",
        17: "ctrl",
        18: "alt",
        27: "esc",
        32: "space",
        33: "pageup",
        34: "pagedown",
        35: "end",
        36: "home",
        37: "left",
        38: "up",
        39: "right",
        40: "down",
        45: "insert",
        46: "delete",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        219: "[",
        220: "\\",
        221: "]",
        222: "'"
    };
    KeyboardState.status = {};
    return KeyboardState;
})();
var RunningElderly;
(function (RunningElderly) {
    function ab2str(buf) {
        return String.fromCharCode.apply(null, new Uint8Array(buf));
    }
    var SerialState = (function () {
        function SerialState(onLineReceived) {
            var _this = this;
            this.id = 0;
            this.devicePath = "";
            this.strReceived = "";
            chrome.serial.getDevices(function (ports) {
                for (var i = 0; i < ports.length; ++i) {
                    if (ports[i].path.indexOf("/dev/cu.wch ch341") > -1) {
                        console.log(ports[i].path);
                        _this.devicePath = ports[i].path;
                        break;
                    }
                }
                _this._onLineReceived = onLineReceived;
                _this.connect();
            });
        }
        SerialState.prototype.connect = function () {
            var _this = this;
            if (this.devicePath === "") {
                console.log("No device found!");
            }
            else {
                chrome.serial.connect(this.devicePath, { bitrate: 115200 }, function (info) {
                    console.log(info);
                    _this.id = info.connectionId;
                });
                chrome.serial.onReceive.addListener(function (info) {
                    if (info.connectionId == _this.id && info.data) {
                        var str = ab2str(info.data);
                        if (str.charAt(str.length - 1) === "\n") {
                            _this.strReceived += str.substring(0, str.length - 1);
                            _this._onLineReceived(_this.strReceived);
                            _this.strReceived = "";
                        }
                        else {
                            _this.strReceived += str;
                        }
                    }
                });
            }
        };
        return SerialState;
    })();
    RunningElderly.SerialState = SerialState;
})(RunningElderly || (RunningElderly = {}));
var RunningElderly;
(function (RunningElderly) {
    RunningElderly.SEGMENT_LENGTH = 48;
    RunningElderly.TRACK_WIDTH = 8;
    RunningElderly.MAX_SEGMENT_NUMBER = 2;
    RunningElderly.mode = "market";
    RunningElderly.resources = {
        textures: new collections.Dictionary(),
        materials: new collections.Dictionary(),
        meshes: new collections.Dictionary()
    };
    function loadResources() {
        RunningElderly.resources.textures.setValue("elderly_left", THREE.ImageUtils.loadTexture("img/elderly_left.png"));
        RunningElderly.resources.textures.setValue("elderly_middle", THREE.ImageUtils.loadTexture("img/elderly_back.png"));
        RunningElderly.resources.textures.setValue("elderly_right", THREE.ImageUtils.loadTexture("img/elderly_right.png"));
        RunningElderly.resources.textures.setValue("insect", THREE.ImageUtils.loadTexture("img/scene_1/insect.png"));
        RunningElderly.resources.textures.setValue("egg", THREE.ImageUtils.loadTexture("img/scene_1/egg.png"));
        RunningElderly.resources.textures.setValue("eggplant", THREE.ImageUtils.loadTexture("img/scene_1/eggplant.png"));
        RunningElderly.resources.textures.setValue("tomato", THREE.ImageUtils.loadTexture("img/scene_1/tomato.png"));
        RunningElderly.resources.textures.setValue("carrot", THREE.ImageUtils.loadTexture("img/scene_1/carrot.png"));
        RunningElderly.resources.textures.setValue("paprika", THREE.ImageUtils.loadTexture("img/scene_1/paprika.png"));
        RunningElderly.resources.textures.setValue("archway1", THREE.ImageUtils.loadTexture("img/scene_1/archway.png"));
        RunningElderly.resources.textures.setValue("basin", THREE.ImageUtils.loadTexture("img/scene_2/basin.png"));
        RunningElderly.resources.textures.setValue("fan", THREE.ImageUtils.loadTexture("img/scene_2/fan.png"));
        RunningElderly.resources.textures.setValue("stool", THREE.ImageUtils.loadTexture("img/scene_2/stool.png"));
        RunningElderly.resources.textures.setValue("thermos", THREE.ImageUtils.loadTexture("img/scene_2/thermos.png"));
        RunningElderly.resources.textures.setValue("towel", THREE.ImageUtils.loadTexture("img/scene_2/towel.png"));
        RunningElderly.resources.textures.setValue("archway2", THREE.ImageUtils.loadTexture("img/scene_2/archway.png"));
        RunningElderly.resources.textures.setValue("clothes", THREE.ImageUtils.loadTexture("img/scene_3/clothes.png"));
        RunningElderly.resources.textures.setValue("hat", THREE.ImageUtils.loadTexture("img/scene_3/hat.png"));
        RunningElderly.resources.textures.setValue("scarf", THREE.ImageUtils.loadTexture("img/scene_3/scarf.png"));
        RunningElderly.resources.textures.setValue("shose", THREE.ImageUtils.loadTexture("img/scene_3/shose.png"));
        RunningElderly.resources.textures.setValue("trouser", THREE.ImageUtils.loadTexture("img/scene_3/trouser.png"));
        RunningElderly.resources.textures.setValue("archway3", THREE.ImageUtils.loadTexture("img/scene_3/archway.png"));
        RunningElderly.resources.textures.setValue("left1", THREE.ImageUtils.loadTexture("img/left1.png"));
        RunningElderly.resources.textures.setValue("left2", THREE.ImageUtils.loadTexture("img/left2.png"));
        RunningElderly.resources.textures.setValue("left3", THREE.ImageUtils.loadTexture("img/left3.png"));
        RunningElderly.resources.textures.setValue("left4", THREE.ImageUtils.loadTexture("img/left4.png"));
        RunningElderly.resources.textures.setValue("right1", THREE.ImageUtils.loadTexture("img/right1.png"));
        RunningElderly.resources.textures.setValue("right2", THREE.ImageUtils.loadTexture("img/right2.png"));
        RunningElderly.resources.textures.setValue("right3", THREE.ImageUtils.loadTexture("img/right3.png"));
        RunningElderly.resources.textures.forEach(function (key, value) {
            value.minFilter = THREE.LinearMipMapNearestFilter;
            value.magFilter = THREE.NearestFilter;
            value.anisotropy = 8;
        });
    }
    RunningElderly.loadResources = loadResources;
    var REScene = (function (_super) {
        __extends(REScene, _super);
        function REScene() {
            _super.apply(this, arguments);
        }
        REScene.prototype.getObjectById = function (id) {
            return _super.prototype.getObjectById.call(this, id);
        };
        REScene.prototype.removeObjectById = function (id) {
            _super.prototype.remove.call(this, _super.prototype.getObjectById.call(this, id));
        };
        return REScene;
    })(THREE.Scene);
    RunningElderly.REScene = REScene;
})(RunningElderly || (RunningElderly = {}));
var RunningElderly;
(function (RunningElderly) {
    var SEGMENT_LENGTH = 60;
    var OBJECT_WIDTH = 30;
    var MAX_SEGMENT_NUMBER = 4;
    var EnvironmentManager = (function () {
        function EnvironmentManager(scene) {
            var _this = this;
            this.animate = function () {
                if (_this.segmentIds.length == 0) {
                    var environmentSegment = new EnvironmentSegment();
                    _this.segmentIds.push(environmentSegment.id);
                    environmentSegment.add(new RoadEnvironmentObject(new THREE.Vector3(0, RunningElderly.TRACK_WIDTH * 1.5, 130)));
                    _this.scene.add(environmentSegment);
                }
                if (_this.scene.getObjectById(_this.segmentIds[0]).position.z >= SEGMENT_LENGTH) {
                    _this.scene.removeObjectById(_this.segmentIds[0]);
                    _this.segmentIds = _this.segmentIds.slice(1, _this.segmentIds.length);
                }
                if (_this.segmentIds.length <= MAX_SEGMENT_NUMBER && _this.scene.getObjectById(_this.segmentIds[_this.segmentIds.length - 1]).position.z >= -(MAX_SEGMENT_NUMBER - 1) * SEGMENT_LENGTH) {
                    var environmentSegment = new EnvironmentSegment();
                    _this.segmentIds.push(environmentSegment.id);
                    _this.scene.add(environmentSegment);
                }
                _this.segmentIds.forEach(function (segmentId) {
                    _this.scene.getObjectById(segmentId).position.z += 0.1;
                });
            };
            this.scene = scene;
            this.segmentIds = new Array();
        }
        EnvironmentManager.prototype.getObstacle = function (id) {
            return this.scene.getObjectById(id);
        };
        EnvironmentManager.prototype.getAllObstacles = function () {
            var _this = this;
            var obstacles = new Array();
            this.segmentIds.forEach(function (segmentId) {
                _this.scene.getObjectById(segmentId).children.forEach(function (track) {
                    track.children.forEach(function (obj) {
                        if (obj instanceof EnvironmentObject) {
                            obstacles.push(obj);
                        }
                    });
                });
            });
            return obstacles;
        };
        return EnvironmentManager;
    })();
    RunningElderly.EnvironmentManager = EnvironmentManager;
    var EnvironmentSegment = (function (_super) {
        __extends(EnvironmentSegment, _super);
        function EnvironmentSegment() {
            _super.call(this);
            this.environmentLeft = new LeftEnvironment(EnvironmentSegment.indexLeft);
            this.add(this.environmentLeft);
            this.environmentRight = new RightEnvironment(EnvironmentSegment.indexRight);
            this.add(this.environmentRight);
            this.translateZ(-MAX_SEGMENT_NUMBER * SEGMENT_LENGTH);
            if (EnvironmentSegment.indexLeft < 3) {
                ++EnvironmentSegment.indexLeft;
            }
            else {
                EnvironmentSegment.indexLeft = 0;
            }
            if (EnvironmentSegment.indexRight < 2) {
                ++EnvironmentSegment.indexRight;
            }
            else {
                EnvironmentSegment.indexRight = 0;
            }
        }
        EnvironmentSegment.indexLeft = 0;
        EnvironmentSegment.indexRight = 0;
        return EnvironmentSegment;
    })(THREE.Group);
    var LeftEnvironment = (function (_super) {
        __extends(LeftEnvironment, _super);
        function LeftEnvironment(index) {
            _super.call(this);
            this.add(new LeftEnvironmentObject(index, new THREE.Vector3(0, OBJECT_WIDTH / 2, 0)));
            this.translateX(-RunningElderly.TRACK_WIDTH - OBJECT_WIDTH);
        }
        return LeftEnvironment;
    })(THREE.Group);
    var RightEnvironment = (function (_super) {
        __extends(RightEnvironment, _super);
        function RightEnvironment(index) {
            _super.call(this);
            this.add(new RightEnvironmentObject(index, new THREE.Vector3(0, OBJECT_WIDTH / 2, 0)));
            this.translateX(RunningElderly.TRACK_WIDTH + OBJECT_WIDTH);
        }
        return RightEnvironment;
    })(THREE.Group);
    var EnvironmentObject = (function (_super) {
        __extends(EnvironmentObject, _super);
        function EnvironmentObject(index, position, imgPath, width, height) {
            var geometry = new THREE.PlaneBufferGeometry(width, height || OBJECT_WIDTH * 1.5);
            this.material = new THREE.MeshBasicMaterial({
                map: RunningElderly.resources.textures.getValue(imgPath),
                transparent: true,
                side: THREE.FrontSide
            });
            _super.call(this, geometry, this.material);
            this.position.set(position.x, position.y, position.z);
        }
        return EnvironmentObject;
    })(THREE.Mesh);
    var RoadEnvironmentObject = (function (_super) {
        __extends(RoadEnvironmentObject, _super);
        function RoadEnvironmentObject(position) {
            _super.call(this, 0, position, "archway1", RunningElderly.TRACK_WIDTH * 5, RunningElderly.TRACK_WIDTH * 3);
        }
        return RoadEnvironmentObject;
    })(EnvironmentObject);
    var LeftEnvironmentObject = (function (_super) {
        __extends(LeftEnvironmentObject, _super);
        function LeftEnvironmentObject(index, position) {
            _super.call(this, index, position, "left" + ++index, OBJECT_WIDTH * 1.5);
        }
        return LeftEnvironmentObject;
    })(EnvironmentObject);
    var RightEnvironmentObject = (function (_super) {
        __extends(RightEnvironmentObject, _super);
        function RightEnvironmentObject(index, position) {
            _super.call(this, index, position, "right" + ++index, OBJECT_WIDTH * 1.5);
        }
        return RightEnvironmentObject;
    })(EnvironmentObject);
})(RunningElderly || (RunningElderly = {}));
var RunningElderly;
(function (RunningElderly) {
    var marketRewardImg = ["carrot", "paprika", "egg", "eggplant", "tomato"];
    var groceryRewardImg = ["basin", "fan", "stool", "thermos", "towel"];
    var clothRewardImg = ["clothes", "hat", "scarf", "shose", "trouser"];
    var RoadManager = (function () {
        function RoadManager(scene) {
            var _this = this;
            this.animate = function (keyboard, speed) {
                if (_this.segmentIds.length == 0) {
                    var roadSegment = new RoadSegment();
                    _this.segmentIds.push(roadSegment.id);
                    _this.scene.add(roadSegment);
                }
                if (_this.scene.getObjectById(_this.segmentIds[0]).position.z >= RunningElderly.SEGMENT_LENGTH) {
                    _this.scene.removeObjectById(_this.segmentIds[0]);
                    _this.segmentIds = _this.segmentIds.slice(1, _this.segmentIds.length);
                }
                if (_this.segmentIds.length <= RunningElderly.MAX_SEGMENT_NUMBER && _this.scene.getObjectById(_this.segmentIds[_this.segmentIds.length - 1]).position.z >= -(RunningElderly.MAX_SEGMENT_NUMBER - 1) * RunningElderly.SEGMENT_LENGTH) {
                    var roadSegment = new RoadSegment();
                    _this.segmentIds.push(roadSegment.id);
                    _this.scene.add(roadSegment);
                }
                _this.segmentIds.forEach(function (segmentId) { return _this.scene.getObjectById(segmentId).position.z += speed; });
            };
            this.scene = scene;
            this.segmentIds = new Array();
        }
        RoadManager.prototype.getObstacle = function (id) {
            return this.scene.getObjectById(id);
        };
        RoadManager.prototype.getAllObstacles = function () {
            var _this = this;
            var obstacles = new Array();
            this.segmentIds.forEach(function (segmentId) {
                _this.scene.getObjectById(segmentId).children.forEach(function (track) {
                    track.children.forEach(function (obj) {
                        if (obj instanceof RoadObstacle) {
                            obstacles.push(obj);
                        }
                    });
                });
            });
            return obstacles;
        };
        return RoadManager;
    })();
    RunningElderly.RoadManager = RoadManager;
    var RoadSegment = (function (_super) {
        __extends(RoadSegment, _super);
        function RoadSegment() {
            _super.call(this);
            var arr = new Array();
            while (arr.length < 3) {
                var randomnumber = Math.round(Math.random() * 2.5) * 2;
                var found = false;
                for (var i = 0; i < arr.length; ++i) {
                    if (arr[i] == randomnumber) {
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    arr[arr.length] = randomnumber;
                }
            }
            this.roadTrackLeft = new RoadTrackLeft(arr[0]);
            this.add(this.roadTrackLeft);
            this.roadTrackMiddle = new RoadTrackMiddle(arr[1]);
            this.add(this.roadTrackMiddle);
            this.roadTrackRight = new RoadTrackRight(arr[2]);
            this.add(this.roadTrackRight);
            this.translateZ(-RunningElderly.MAX_SEGMENT_NUMBER * RunningElderly.SEGMENT_LENGTH);
        }
        return RoadSegment;
    })(THREE.Group);
    var RoadTrack = (function (_super) {
        __extends(RoadTrack, _super);
        function RoadTrack(obstaclePosition) {
            _super.call(this);
            var roadSurface = new RoadSurface();
            this.add(roadSurface);
            this.add(Math.random() >= 0.5 ? new RewardObstacle(obstaclePosition, roadSurface.position) : new TrapObstacle(obstaclePosition, roadSurface.position));
        }
        RoadTrack.prototype.addObstacle = function (obstacle) {
            this.add(obstacle);
        };
        RoadTrack.prototype.addObstacles = function (obstacles) {
            var _this = this;
            obstacles.forEach(function (obs) { return _this.add(obs); });
        };
        RoadTrack.prototype.removeObstacle = function (obstacle) {
            this.remove(obstacle);
        };
        return RoadTrack;
    })(THREE.Group);
    var RoadTrackLeft = (function (_super) {
        __extends(RoadTrackLeft, _super);
        function RoadTrackLeft(obstaclePosition) {
            _super.call(this, obstaclePosition);
            this.translateX(RunningElderly.TRACK_WIDTH);
        }
        return RoadTrackLeft;
    })(RoadTrack);
    var RoadTrackMiddle = (function (_super) {
        __extends(RoadTrackMiddle, _super);
        function RoadTrackMiddle(obstaclePosition) {
            _super.call(this, obstaclePosition);
        }
        return RoadTrackMiddle;
    })(RoadTrack);
    var RoadTrackRight = (function (_super) {
        __extends(RoadTrackRight, _super);
        function RoadTrackRight(obstaclePosition) {
            _super.call(this, obstaclePosition);
            this.translateX(-RunningElderly.TRACK_WIDTH);
        }
        return RoadTrackRight;
    })(RoadTrack);
    var RoadSurface = (function (_super) {
        __extends(RoadSurface, _super);
        function RoadSurface() {
            var geometry = new THREE.PlaneBufferGeometry(RunningElderly.TRACK_WIDTH, RunningElderly.SEGMENT_LENGTH);
            var material = new THREE.MeshBasicMaterial({
                transparent: true,
                opacity: 0,
                side: THREE.FrontSide
            });
            _super.call(this, geometry, material);
            this.rotateX(Math.PI / 2);
        }
        return RoadSurface;
    })(THREE.Mesh);
    var RoadObstacle = (function (_super) {
        __extends(RoadObstacle, _super);
        function RoadObstacle(index, position, imgPath) {
            var geometry = new THREE.PlaneBufferGeometry(RunningElderly.TRACK_WIDTH / 2, RunningElderly.TRACK_WIDTH / 2);
            var material = new THREE.MeshBasicMaterial({
                map: RunningElderly.resources.textures.getValue(imgPath),
                transparent: true,
                side: THREE.FrontSide
            });
            _super.call(this, geometry, material);
            this.position.set(position.x, position.y + RunningElderly.TRACK_WIDTH * 0.5, position.z + index * RunningElderly.TRACK_WIDTH - RunningElderly.SEGMENT_LENGTH * 0.5);
        }
        return RoadObstacle;
    })(THREE.Mesh);
    RunningElderly.RoadObstacle = RoadObstacle;
    var RewardObstacle = (function (_super) {
        __extends(RewardObstacle, _super);
        function RewardObstacle(index, position) {
            if (RunningElderly.mode === "market") {
                _super.call(this, index, position, marketRewardImg[Math.floor(Math.random() * marketRewardImg.length)]);
            }
            else if (RunningElderly.mode === "grocery") {
                _super.call(this, index, position, groceryRewardImg[Math.floor(Math.random() * groceryRewardImg.length)]);
            }
            else if (RunningElderly.mode === "cloth") {
                _super.call(this, index, position, clothRewardImg[Math.floor(Math.random() * clothRewardImg.length)]);
            }
        }
        return RewardObstacle;
    })(RoadObstacle);
    RunningElderly.RewardObstacle = RewardObstacle;
    var TrapObstacle = (function (_super) {
        __extends(TrapObstacle, _super);
        function TrapObstacle(index, position) {
            _super.call(this, index, position, "insect");
        }
        return TrapObstacle;
    })(RoadObstacle);
    RunningElderly.TrapObstacle = TrapObstacle;
})(RunningElderly || (RunningElderly = {}));
var RunningElderly;
(function (RunningElderly) {
    var CharacterManager = (function () {
        function CharacterManager(scene, keyboard) {
            var _this = this;
            this.keyboardAnimate = function (keyboard) {
                if (keyboard.down("left")) {
                    _this.character.moveLeft();
                }
                else if (keyboard.down("right")) {
                    _this.character.moveRight();
                }
            };
            this.serialAnimate = function (signal) {
                if (signal.charAt(0) === "l") {
                    _this.character.moveToLeft();
                }
                else if (signal.charAt(0) === "r") {
                    _this.character.moveToRight();
                }
                else if (signal.charAt(0) === "m") {
                    _this.character.moveToMiddle();
                }
                _this.lastReceived = signal;
            };
            this.removeCollidedObjs = function (objs, counter) {
                _this.rayCaster.set(new THREE.Vector3(_this.character.position.x, _this.character.position.y, _this.character.position.z - RunningElderly.TRACK_WIDTH / 4), new THREE.Vector3(0, 1, -0.5));
                var intersects = _this.rayCaster.intersectObjects(objs);
                for (var i = 0; i < intersects.length; ++i) {
                    if (intersects[i].object instanceof RunningElderly.RewardObstacle) {
                        intersects[i].object.parent.remove(intersects[i].object);
                        counter.increment();
                    }
                    else if (intersects[i].object instanceof RunningElderly.TrapObstacle) {
                        intersects[i].object.parent.remove(intersects[i].object);
                        counter.decrement();
                    }
                }
            };
            this.character = new Character();
            this.rayCaster = new THREE.Raycaster();
            scene.add(this.character);
        }
        return CharacterManager;
    })();
    RunningElderly.CharacterManager = CharacterManager;
    var CharacterDummy = (function (_super) {
        __extends(CharacterDummy, _super);
        function CharacterDummy() {
            var geometry = new THREE.PlaneBufferGeometry(RunningElderly.TRACK_WIDTH, RunningElderly.TRACK_WIDTH);
            var texture = RunningElderly.resources.textures.getValue("elderly_middle");
            this.material = new THREE.MeshBasicMaterial({
                map: texture,
                color: 0xffffff,
                transparent: true,
                side: THREE.FrontSide
            });
            _super.call(this, geometry, this.material);
            this.lookAt(new THREE.Vector3(0, 15, 30));
        }
        return CharacterDummy;
    })(THREE.Mesh);
    var Character = (function (_super) {
        __extends(Character, _super);
        function Character() {
            _super.call(this);
            this.characterDummy = new CharacterDummy();
            this.add(this.characterDummy);
            var geometry = new THREE.PlaneBufferGeometry(RunningElderly.TRACK_WIDTH * 0.8, RunningElderly.TRACK_WIDTH * 0.8);
            var material = new THREE.MeshBasicMaterial({
                visible: false
            });
            this.collisionPlane = new THREE.Mesh(geometry, material);
            this.collisionPlane.name = "collisionPlane";
            this.collisionPlane.translateZ(-RunningElderly.TRACK_WIDTH / 4);
            this.add(this.collisionPlane);
            this.position.set(0, RunningElderly.TRACK_WIDTH / 2, RunningElderly.TRACK_WIDTH * 2);
        }
        Character.prototype.moveLeft = function () {
            if (this.position.x > RunningElderly.TRACK_WIDTH * 0.5) {
                this.moveToMiddle();
            }
            else if (this.position.x > -RunningElderly.TRACK_WIDTH * 0.5) {
                this.moveToLeft();
            }
        };
        Character.prototype.moveRight = function () {
            if (this.position.x < -RunningElderly.TRACK_WIDTH * 0.5) {
                this.moveToMiddle();
            }
            else if (this.position.x < RunningElderly.TRACK_WIDTH * 0.5) {
                this.moveToRight();
            }
        };
        Character.prototype.moveToLeft = function () {
            this.characterDummy.material.map = RunningElderly.resources.textures.getValue("elderly_left");
            this.characterDummy.material.needsUpdate = true;
            this.position.x = -RunningElderly.TRACK_WIDTH;
        };
        Character.prototype.moveToMiddle = function () {
            this.characterDummy.material.map = RunningElderly.resources.textures.getValue("elderly_middle");
            this.characterDummy.material.needsUpdate = true;
            this.position.x = 0;
        };
        Character.prototype.moveToRight = function () {
            this.characterDummy.material.map = RunningElderly.resources.textures.getValue("elderly_right");
            this.characterDummy.material.needsUpdate = true;
            this.position.x = RunningElderly.TRACK_WIDTH;
        };
        return Character;
    })(THREE.Group);
    RunningElderly.Character = Character;
    ;
})(RunningElderly || (RunningElderly = {}));
var ScoreCounter = (function () {
    function ScoreCounter(domElement) {
        this.score = 0;
        this.domElement = domElement;
        if (typeof this.domElement != "undefined") {
            this.domElement.setAttribute("style", "padding: 10px; font-size: 64px;");
        }
        this._updateDisplay();
        this.domElement.onclick = function () {
            chrome.app.window.current().outerBounds.setSize(window.screen.availWidth, window.screen.availHeight);
        };
        var finishScreen = document.createElement("img");
        finishScreen.setAttribute("src", "img/first.png");
        finishScreen.setAttribute("width", "1024");
        finishScreen.setAttribute("height", "768");
        finishScreen.setAttribute("style", "position: fixed; left: 0; top: 0; z-index: 9; opacity: 0.9;");
        document.body.appendChild(finishScreen);
        setTimeout(function () {
            finishScreen.parentNode.removeChild(finishScreen);
        }, 2000);
    }
    ScoreCounter.prototype._updateDisplay = function () {
        if (this.score >= 10 && RunningElderly.mode === "market") {
            RunningElderly.mode = "grocery";
            var finishScreen = document.createElement("img");
            finishScreen.setAttribute("src", "img/second.png");
            finishScreen.setAttribute("width", "1024");
            finishScreen.setAttribute("height", "768");
            finishScreen.setAttribute("style", "position: fixed; left: 0; top: 0; z-index: 9; opacity: 0.9;");
            document.body.appendChild(finishScreen);
            setTimeout(function () {
                finishScreen.parentNode.removeChild(finishScreen);
            }, 2000);
        }
        else if (this.score >= 20 && RunningElderly.mode === "grocery") {
            RunningElderly.mode = "cloth";
            var finishScreen = document.createElement("img");
            finishScreen.setAttribute("src", "img/third.png");
            finishScreen.setAttribute("width", "1024");
            finishScreen.setAttribute("height", "768");
            finishScreen.setAttribute("style", "position: fixed; left: 0; top: 0; z-index: 9; opacity: 0.9;");
            document.body.appendChild(finishScreen);
            setTimeout(function () {
                finishScreen.parentNode.removeChild(finishScreen);
            }, 2000);
        }
        else if (this.score >= 30) {
            var finishScreen = document.createElement("img");
            finishScreen.setAttribute("src", "img/finish.png");
            finishScreen.setAttribute("width", "1024");
            finishScreen.setAttribute("height", "768");
            finishScreen.setAttribute("style", "position: fixed; left: 0; bottom: 0; z-index: 9;");
            document.body.appendChild(finishScreen);
        }
        this.domElement.innerHTML = this.score.toString();
    };
    ScoreCounter.prototype.getScore = function () {
        return this.score;
    };
    ScoreCounter.prototype.reset = function () {
        this.score = 0;
        this._updateDisplay();
    };
    ScoreCounter.prototype.increment = function () {
        ++this.score;
        this._updateDisplay();
    };
    ScoreCounter.prototype.decrement = function () {
        --this.score;
        this._updateDisplay();
    };
    return ScoreCounter;
})();
var RunningElderly;
(function (RunningElderly) {
    var scene;
    var camera;
    var renderer;
    var raycaster;
    var Game = (function () {
        function Game(domElem) {
            var _this = this;
            RunningElderly.loadResources();
            scene = new RunningElderly.REScene();
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10000);
            renderer = new THREE.WebGLRenderer({
                precision: "highp",
                antialias: true,
                alpha: true
            });
            raycaster = new THREE.Raycaster();
            renderer.setClearColor(0xffffff, 0);
            camera.position.y = 15;
            camera.position.z = 30;
            camera.lookAt(scene.position);
            renderer.setSize(1024, 768);
            this.bindTo(domElem);
            this.speed = 0.1;
            this.motion = "m";
            this.repeatCount = 1;
            this.stop = false;
            this.keyboard = new KeyboardState();
            this.serial = new RunningElderly.SerialState(function (str) {
                if (str.charAt(0) === "w") {
                    _this.speed = 0.1 + Math.min(3, parseInt(str.slice(2, str.length)) / 80);
                }
                else if (str.charAt(0) === "s") {
                    _this.motion = str.slice(2, str.length);
                }
            });
            this.environmentManager = new RunningElderly.EnvironmentManager(scene);
            this.roadManager = new RunningElderly.RoadManager(scene);
            this.characterManager = new RunningElderly.CharacterManager(scene, this.keyboard);
        }
        Game.prototype.bindTo = function (domElem) {
            domElem.appendChild(renderer.domElement);
        };
        Game.prototype.start = function () {
            this.counter = new ScoreCounter((document.getElementsByClassName("my-counter")[0]));
            this.render();
        };
        Game.prototype.restart = function () {
            this.stop = true;
            this.counter.reset();
            this.clear(scene);
            renderer.clear();
            this.speed = 0.1;
            this.motion = "m";
            this.repeatCount = 1;
            this.stop = false;
            RunningElderly.mode = "market";
            this.environmentManager = new RunningElderly.EnvironmentManager(scene);
            this.roadManager = new RunningElderly.RoadManager(scene);
            this.characterManager = new RunningElderly.CharacterManager(scene, this.keyboard);
            this.stop = false;
            this.render();
        };
        Game.prototype.clear = function (element) {
            var children = element.children;
            for (var i = children.length - 1; i >= 0; i--) {
                var child = children[i];
                this.clear(child);
                child.parent.remove(child);
            }
            ;
        };
        Game.prototype.render = function () {
            var _this = this;
            var id;
            if (!this.stop) {
                id = requestAnimationFrame(function () { return _this.render(); });
            }
            else {
                cancelAnimationFrame(id);
            }
            this.keyboard.update();
            this.environmentManager.animate();
            this.roadManager.animate(this.keyboard, this.speed);
            this.characterManager.keyboardAnimate(this.keyboard);
            this.characterManager.serialAnimate(this.motion);
            this.characterManager.removeCollidedObjs(this.roadManager.getAllObstacles(), this.counter);
            renderer.render(scene, camera);
        };
        return Game;
    })();
    RunningElderly.Game = Game;
})(RunningElderly || (RunningElderly = {}));
window.onload = function () {
    var game = new RunningElderly.Game(document.body);
    var btnRestart = document.getElementsByClassName("btn-restart")[0];
    btnRestart.onclick = function () {
        game.restart();
    };
    var videoElem = document.getElementById("intro-video");
    videoElem.addEventListener("ended", function (event) {
        game.start();
    }, false);
    var btnSkip = document.getElementsByClassName("btn-skip")[0];
    btnSkip.onclick = function (event) {
        document.body.removeChild(videoElem);
        btnSkip.parentNode.removeChild(btnSkip);
        game.start();
    };
};

//# sourceMappingURL=app.min.js.map